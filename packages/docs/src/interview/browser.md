# 浏览器篇

## 从输入 URL 到页面展示，这中间发生了什么？ {#urlToPage}

1. 浏览器查找当前URL是否存在缓存，如果有缓存、并且缓存未过期，直接从缓存中返回。
2. 查看域名是否已经被解析过了，没有解析过进行`DNS`解析将域名解析成`IP`地址，并增加端口号
3. 如果请求是`HTTPS`，进行`SSL`协商
4. 利用`IP`地址进行寻址，请求排队。同一个域名下请求数量不能多余6个(http1.1下,http2.0没有这个限制)。
5. 排队后服务器创建`TCP`链接 （三次握手）
6. 利用`TCP`协议将大文件拆分成数据包进行传输(有序传输)，可靠的传输给服务器（丢包重传），服务器收到后按照序号重排数据包 （增加`TCP`头部，`IP`头部）
7. 发送HTTP请求（请求行，请求头，请求体）
8. HTTP 1.1中支持keep-alive属性,TCP链接不会立即关闭，后续请求可以省去建立链接时间
9. 服务器响应结果（响应行，响应头，响应体）
10. 返回状态码为301、302时，浏览器会进行重定向操作。（重新进行导航）
11. 返回304则查找缓存。（服务端可以设置强制缓存）

## 浏览器是怎样进行渲染的

1. 解析`HTML`，构建`DOM`树
2. 解析`CSS`，构建`CSSOM`树
3. 将`DOM`树和`CSSOM`树结合，生成`Render Tree`
4. 根据`Render Tree`进行布局，计算每个节点的几何信息
5. 根据`Render Tree`进行绘制，将节点绘制到屏幕上

## 浏览器的进程关系

1. 浏览器进程，负责浏览器的主要功能，如地址栏、书签、前进后退、下载等
2. 渲染进程，负责页面的渲染，脚本执行，事件处理等
3. GPU进程，负责页面的`GPU`渲染，合成等
4. 网络进程，负责页面的网络资源加载
5. 插件进程，负责插件的运行，每种类型的插件对应一个进程，仅当使用该插件时才创建
6. 浏览器进程和渲染进程是多对多的关系，一个浏览器进程可以对应多个渲染进程，一个渲染进程只能对应一个浏览器进程

## 浏览器的缓存机制

1. 强缓存，浏览器直接从缓存中读取资源，不会向服务器发送请求，状态码为`200`，`from memory cache`或`from disk cache`。字段为`Expires`和`Cache-Control`，`Expires`是`HTTP1.0`的产物，`Cache-Control`是`HTTP1.1`的产物，优先级`Cache-Control`高于`Expires`。
2. 协商缓存，浏览器向服务器发送请求，服务器根据请求头判断资源是否过期，如果过期则返回新的资源，状态码为`200`，`from memory cache`或`from disk cache`。字段为`Last-Modified`和`ETag`，`Last-Modified`是`HTTP1.0`的产物，`ETag`是`HTTP1.1`的产物，优先级`ETag`高于`Last-Modified`。
3. 强缓存优先级高于协商缓存，如果强缓存生效，则不会进行协商缓存。字段`Cache-Control`的值为`no-cache`时，会进行协商缓存，字段`Cache-Control`的值为`no-store`时，不会进行强缓存和协商缓存。

::: tip 强缓存和协商缓存的区别

- 强缓存不会向服务器发送请求，协商缓存会向服务器发送请求
- 强缓存的状态码为`200`，协商缓存的状态码为`304`
- 强缓存的字段为`Expires`和`Cache-Control`，协商缓存的字段为`Last-Modified`和`ETag`
- 强缓存的优先级高于协商缓存
:::

什么时候用缓存？

- 静态资源，如`js`、`css`、`img`等
- 不需要实时更新的资源，如`CDN`中的资源

什么不需要用缓存？

- 动态资源，如`html`、`json`等
- 实时更新的资源，如`用户信息`、`订单信息`等

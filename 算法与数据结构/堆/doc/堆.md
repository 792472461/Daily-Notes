# 堆

- 1. 堆是一个完全二叉树（完全二叉树：除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。）
- 2. 堆中的每个节点的值必须大于等于（或者小于等于）其子树中每个节点的值。实际上，我们还可以换一种说法，堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。这两种表述是等价的。

## 堆的实现
1. 完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的。因为不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。
2. 数组中下标为*i*的的左节点就是*i * 2 + 2*,右节点就是*i * 2 + 2*
3. 下标为*i*的父节点就是*(i - 1) / 2*

## 插入
1. 插入到数组最后一个
2. 进行上浮
3. 比较自己是否比父元素大，如果比父元素大，交换位置
4. 交换后继续比较，直到比父元素小或者没有父元素 
5. 插入完成

## 删除堆顶元素
1. 把最后一个元素放到堆顶，删除最后一个元素
2. 进行下沉
3. 比较自己两个子节点，找最大的节点，交换位置
4. 交换后继续跟自己自己子节点比较，找到最大的交换位置，
5. 直到找到自己合适的位置（比自己左右节点大）

## 总结
1. 堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 O(n)，排序过程的时间复杂度是 O(nlogn)，所以，堆排序整体的时间复杂度是 O(nlogn)。
2. 整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法
3. 堆排序不是稳定的排序算法，因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。

## 应用场景
1. 利用堆求Top K
2. 利用堆求中位数
3. 优先级队列
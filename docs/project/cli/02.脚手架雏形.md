# 脚手架雏形

1. 创建项目
```shell
mkdir cli
cd cli 
npm init
```
2. 新建程序入口文件
```shell
touch cli.js
```
3. 在package.json中添加bin
```json
{
  "name": "cli",
  "version": "1.0.0",
  "description": "",
  "bin": {
    "xxx-cli": "bin/cli.js"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC"
}
```
4. 编辑cli.js
```javascript
#! /usr/bin/env node

// 检查入口是否执行
console.log('cli working...')
```
5. 添加软连接，输入```npm link```
6. 在命令行中输入cli


## npm link标准流程
链接本地脚手架
```
cd xxx-cli
npm link
```
取消链接本地库文件
```
cd xxx-cli
npm unlink
```
理解link
> link的本质就是软链接
- npm link: 将当前目录链接到```node```全局```node_modules```中作为一个库文件，并解析```bin```配置的可可执行文件
- npm link xxx: 将当前的```node_modules```下指定的库文件链接到```node```全局```node_modules```的xxx库文件

> unlink本质就是删除这条软链接
- npm unlink: 将当前项目从```node```全局```node_modules```中移除
- npm unlink xxx: 将当前项目中的库文件依赖移除

## 命令行参数解析
修改cli文件
```javascript
#! /usr/bin/env node

// 定义库文件
const utils = {
  init({ option, parma }) {
    console.log('init', option, parma)
  }
}

// 注册一个命令
const argv = require("process").argv

console.log(argv)


const command = argv[2]

const options = argv.slice(3);
let [option, parma] = options

option = option.replace('--', '')
console.log(option, parma)

if (utils[command]) {
  utils[command]({ option, parma })
} else {
  console.log('无效的命令')
}

// 检查入口是否执行
console.log('cli working...')
```

命令行执行
> xxx-cli init --name test

就会输出 ```init name cli-test```

以上就实现了一个比较简单的命令行解析

现在已经有比较成熟的库了，我们引入一下这个库：command